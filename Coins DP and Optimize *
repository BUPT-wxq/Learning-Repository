面试题 08.11. 硬币
硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

示例1:

 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
示例2:

 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1


#most direct way dp[i][j] means the method numbers of the front ith coin constitute j yuan
#time complexity is O(len(coins)*n*(n/min(coins)))
#leetcode exceed time
class Solution:
    def waysToChange(self, n: int) -> int:
        mod = 10**9 + 7
        coins = [1,5,10,25]
        dp=[]
        for i in range(4):
            dp.append([])
            dp[i].append(1)
            for j in range(n):
                dp[i].append(0)
        for j in range(1,n+1):
            dp[0][j]=1
        for i in range(1,4):
            for j in range(1,n+1):
                k=0
                while j-k*coins[i]>=0:
                    dp[i][j] += dp[i - 1][j - k * coins[i]]
                    k=k+1
        return dp[3][n] % mod
#The following is optimize    complete bag question
#The key  dp[i][j]=dp[i-1][j]+dp[i][j-coin[i]]+dp[i][j-2*coin[i]].....
#         dp[i][j-coin[i]]=dp[i-1][j-coin[i]]+dp[i-1][j-2*coin[i]]......
#         replace:dp[i][j]=dp[i-1][j]+dp[i][j-coin[i]]
#time complxity is O(len(coins)*n)
#leetcode pass
class Solution:
    def waysToChange(self, n: int) -> int:
        mod = 10**9 + 7
        coins = [1,5,10,25]
        dp=[]
        for i in range(4):
            dp.append([])
            dp[i].append(1)
            for j in range(n):
                dp[i].append(0)
        for j in range(1,n+1):
            dp[0][j]=1
        for i in range(1,4):
            for j in range(1,n+1):
                dp[i][j]=dp[i-1][j]
                if j-coins[i]>=0:
                    dp[i][j]+=dp[i][j-coins[i]]
        return dp[3][n] % mod
        
