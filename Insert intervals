给出一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

示例 1:

输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
输出: [[1,5],[6,9]]
示例 2:

输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出: [[1,2],[3,10],[12,16]]
解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

func insert(intervals [][]int, newInterval []int) [][]int {
	answer:=[][]int{}
	low:=newInterval[0]
	high:=newInterval[1]
	if len(intervals)==0 {
		return [][]int{{low,high}}
	}
	var a int
	var b []int
	for a,b=range intervals{
		if low<b[0] {
			answer=append(answer,[]int{0,0})
			answer[a][0]=low
			break
		} else if low>=b[0] &&low<= b[1] {
			answer=append(answer,[]int{0,0})
			answer[a][0]=b[0]
			break
		} else if low >b[1] {
			answer=append(answer,b)
			if a==len(intervals)-1 {
				answer=append(answer,newInterval)
				return answer
			}
		}
	}
	i:=a
	for i<len(intervals) {
		if high<intervals[i][0] {
			answer[a][1]=high
			for i<len(intervals){
				answer=append(answer,intervals[i])
				i++
			}
			return answer
		} else if high>=intervals[i][0] &&high<= intervals[i][1] {
			answer[a][1]= intervals[i][1]
			i++
			for i<len(intervals){
				answer=append(answer,intervals[i])
				i++
			}
			return answer
		} else if high >intervals[i][1] {
			i++
		}
	}
	if i==len(intervals) {
		answer[a][1]=high
	}
	return answer
}
