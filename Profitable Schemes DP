帮派里有 G 名成员，他们可能犯下各种各样的罪行。

第 i 种犯罪会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。

让我们把这些犯罪的任何子集称为盈利计划，该计划至少产生 P 的利润。

有多少种方案可以选择？因为答案很大，所以返回它模 10^9 + 7 的值。

 

示例 1：

输入：G = 5, P = 3, group = [2,2], profit = [2,3]
输出：2
解释： 
至少产生 3 的利润，该帮派可以犯下罪 0 和罪 1 ，或仅犯下罪 1 。
总的来说，有两种方案。
示例 2:

输入：G = 10, P = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：
至少产生 5 的利润，只要他们犯其中一种罪就行，所以该帮派可以犯下任何罪行 。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。

func profitableSchemes(G int, P int, group []int, profit []int) int {
	MOD:=int(math.Pow(10,9)+7)
	dp:=make([][][]int,len(group))
	for i:=range dp {
		dp[i]=make([][]int,G+1)
		for j:=range dp[i]{
			dp[i][j]=make([]int,P+1)
		}
	}
	for j:=0;j<=G ;j++  {
		dp[0][j][0]=1
	}
	for j:=0;j<=G;j++{
		if j>=group[0] {
			var k int
			for k=0;k<=profit[0]&&k<=P;k++{
				if k==0 {
					dp[0][j][k]=2
				}else {
					dp[0][j][k]=1
				}

			}
			for ;k<=P;k++ {
				dp[0][j][k]=0
			}
		}
	}
	for i:=1;i<len(group) ;i++ {
		for j:=0;j<=G;j++{
			for k:=0;k<=P;k++ {
				if j-group[i]>=0{
					if k-profit[i]<=0{
						dp[i][j][k]=dp[i-1][j-group[i]][0]+dp[i-1][j][k]
						dp[i][j][k]%=MOD

					}else {
						dp[i][j][k]=dp[i-1][j-group[i]][k-profit[i]]+dp[i-1][j][k]
						dp[i][j][k]%=MOD
					}
				}else {
					dp[i][j][k]=dp[i-1][j][k]
				}
			}
		}
	}
	return dp[len(group)-1][G][P]%MOD
}
